/* ΚΛΑΣΕΙΣ & ΔΕΙΚΤΕΣ */

/***************** Δυναμική δέσμευση μνήμης για Πίνακες **********************/

/*
Χρησιμοποιούμε τους ίδιους τελεστές {new, delete}.

### ΔΙΔΙΑΣΤΑΤΟΙ ###

Ένας διδιάστατος πίνακας MxN (Μ=στήλες, Ν=γραμμές), ας υποθέσουμε ακεραίων,
είναι ένας πίνακας Μ δεικτών σε ακέραιο. Όπου κάθε δείκτης είναι ένας πίνακας
Ν ακεραίων.
Στην ουσία ο διδιάστατος πίνακας είναι ένας πίνακας δεικτών ακεραίων (αν
υποθέσουμε ότι ο τύπος είναι int).
Δηλ. για να φτιάξω έναν διδιάστατο πίνακα με δυναμική δέσμευση πρέπει να έχω
διπλό δείκτη. Αυτός ο διπλός δείκτης θα δείχνει σε έναν πίνακα από μονούς
δείκτες.


*/
#include <iostream>
using namespace std;

int main()
{
  int **ptr; // Δήλωση ως ΔΙΠΛΟΣ δείκτης (βλ. παρακάτω)
  int i=1,j=1, k = 3, m = 5;

  ptr = new int * [k]; // Δηλώνω έναν πίνακα ΔΕΙΚΤΩΝ σε ακέραιο με διάσταση Μ
  for (i=0; i<k; i++) // Για κάθε στοιχείο του πίνακα δεσμεύω χώρο για
  {
    ptr[i] = new int [m]; // τον πίνακα δεδομένων που με ενδιαφέρει.
    if(!ptr) cout << "Error allocating memory";
  }
   /* Εφόσον το ptr θέλουμε να δείχνει στη διεύθυνση ενός τύπου δεδομένων και
  χρησιμοποιούμε δυναμική δέσμευση, το ptr είναι ΔΙΠΛΟΣ δείκτης {**}
  */

/* Κάποια δουλειά με τον πίνακα */

  for (i=0; i<k; i++)
  {
    for (j=0; j<m; j++)
    ptr[i][j] = i*j;
  }

  for (i=0; i<k; i++)
  {
    for (j=0; j<m; j++)
    cout << ptr[i][j];
    cout << endl;
  }


  /* Αποδέσμευση με συγκεκριμένη σειρά */
  for (i=0; i<k; i++)
  delete [] ptr[i]; // πρώτα αποδέσμευση για τις γραμμές
  delete [] ptr;  // μετά για τις στήλες (στην ουσία μια στήλη του πίνακα
                  // δεικτών)
  /* Αν αποδεσμεύσω πρώτα τη στήλη, η οποία είναι ο πίνακας δεικτών, τότε δεν
  θα έχω πλέον πρόσβαση στις γραμμές που δείχνουν (οι δείκτες) */

  return 0;
}
