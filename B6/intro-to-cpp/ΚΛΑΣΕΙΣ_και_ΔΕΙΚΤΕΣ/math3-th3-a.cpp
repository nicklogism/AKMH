/* ΚΛΑΣΕΙΣ & ΔΕΙΚΤΕΣ */

/******************** Δυναμική δέσμευση για αντικείμενα **********************/

/*
Εφόσον μια κλάση είναι ένας τύπος δεδομένων, μπορεί να δεσμευτεί χώρος δυναμικά
για ένα αντικείμενο της κλάσης.

Όταν χρησιμοποιούμε ένα αντικείμενο μέσω δείκτη, έχουμε πρόσβαση στα δημόσια
μέλη(μεθόδους) του αντικειμένου μέσω του τελεστή {->} (βελάκι). Άλλος τρόπος
είναι με το dereferencing {(*p).x} (Δες Παράδειγμα 1)

Πρόσβαση μπορούμε να έχουμε και χωρίς δυναμική δέσμευση μνήμης, με τον
κλασσικό τρόπο. Δηλαδή, καταχωρώντας τη διεύθυνση του αντικειμένου σε έναν
δείκτη. Στην εκτύπωση όμως πρέπει να χρησιμοποιήσουμε έναν από τους δυο τρόπους
(βελάκι ή dereferencing)
πχ
dummy ob;
dummy *p = &ob;

ob.x = 7; //Ανάθεση τιμής

cout <<"ob.x = "<<p->x<<" or "<<(*p).x<<endl; // Εκτύπωση

*/


#include <iostream>
using namespace std;

/******************************* Παράδειγμα 1 *********************************/
class dummy {
public:
  int x;
  int y;
};

int main()
{
  // Καταλαμβάνουμε το χώρο μνήμης, αλλά δεν δείχνουν κάπου προς το παρόν.
  dummy *ptrx = NULL;
  dummy *ptry = NULL;

  // Δυναμική δέσμευση μνήμης
  ptrx = new dummy;
  ptry = new dummy;

  // Έλεγχος αν η δέσμευση έγινε σωστά
  if(!ptrx) cout << "Error allocating memory";
  if(!ptry) cout << "Error allocating memory";

  // Ανάθεση τιμών με διαφορετικούς τρόπους.

  ptrx->x = 5; /* Η ανάθεση τιμής γίνεται με τον τελεστή {->} εφόσον πρόκειται
  για δείκτη αντικειμένου(p) που δείχνει σε μέλος(x) της κλάσης(dummy) */

  (*ptry).y = 10; //Εναλακτικός τρόπος ανάθεσης τιμής

  // Εκτυπώσεις
  cout <<"ptrx->x = "<<ptrx->x<<endl; // Εκτύπωση
  cout <<"(*ptry).y = "<<(*ptry).y<<endl; // Άλλος τρόπος (dereferencing)

  delete ptrx; // Αποδέσμευση μνήμης
  delete ptry;

  return 0;
}
